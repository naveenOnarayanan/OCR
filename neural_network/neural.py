import network
import learning.backPropogation as learning
import functions.sigmoid as functions
import numpy as np


def norm_and_flatten(mat):
	mat_arr = mat.flatten()
	mat_arr = (mat_arr / 255) - 0.5
	return 	np.array([mat_arr])



def main():

	patternSize = 9
	patterns = 1

	mat = np.array([[ 255,  255,  255,  255,  255,    0,    0,    0,    0,    0,    0,  255,
   255,  255,  255],
 [ 255,  255,  255,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  255,  255],
 [ 255,  255,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  255,  255],
 [ 255,    0,    0,    0,    0,    0,  255,  255,  255,    0,    0,    0,
     0,    0,  255],
 [ 255,    0,    0,    0,    0,  255,  255,  255,  255,  255,    0,    0,
     0,    0,  255],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,  255,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,  255,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,  255,
     0,    0,    0],
 [   0,    0,    0,  255,  255,  255,  255,  255,  255,  255,  255,  255,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [   0,    0,    0,    0,  255,  255,  255,  255,  255,  255,  255,    0,
     0,    0,    0],
 [ 255,    0,    0,    0,    0,  255,  255,  255,  255,  255,    0,    0,
     0,    0,  255],
 [ 255,    0,    0,    0,    0,    0,  255,  255,  255,    0,    0,    0,
     0,    0,  255],
 [ 255,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  255,  255],
 [ 255,  255,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  255,  255],
 [ 255,  255,  255,    0,    0,    0,    0,    0,    0,    0,    0,  255,
   255,  255,  255],
 [ 255,  255,  255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
   255,  255,  255]])
	input_r = norm_and_flatten(mat)


	print(input_r)
	size = input_r.shape[1]
	output_r = np.array()

	net = network.Network(functions.SigmoidFunction(1), patternSize, (size, size, 1))

	learning_alg = learning.BackPropogationLearning(net)

	learning_alg.train(input_r, output_r)


	input2 = np.array([[ 0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,  0.5,
	   0.5,  0.5,  0.5,
	  0.5,  0.5,  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,
	     -0.5,  0.5,  0.5,
	  0.5,  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,
	     -0.5,  0.5,  0.5,
	  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,    -0.5,    -0.5,    -0.5,
	     -0.5,    -0.5,  0.5,
	  0.5,    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  -0.5,  0.5,  -0.5,  0.5,    -0.5,    -0.5,
	     -0.5,    -0.5,  0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    0.5,    -0.5,  0.5,  0.5,  -0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  -0.5,  -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,
	     -0.5,    -0.5,    -0.5,
	  0.5,    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,    -0.5,    -0.5,
	     -0.5,    -0.5,  0.5,
	  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,  0.5,  0.5,  0.5,    -0.5,    -0.5,    -0.5,
	     -0.5,    -0.5,  0.5,
	  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,
	     -0.5,  0.5,  0.5,
	  0.5,  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,
	     -0.5,  0.5,  0.5,
	  0.5,  0.5,  0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,    -0.5,  0.5,
	   0.5,  0.5,  0.5,
	  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
	   0.5,  0.5,  0.5]])

	learning_alg.run(input2)

if __name__ == "__main__":
	main()